// Cavundle creates asset bundles for Caviar-enabled programs.
package main

import (
    "fmt"
    "os"
    "os/exec"
    "path"
    "path/filepath"
    "archive/zip"
    "flag"
    "log"
    "bytes"
    "encoding/gob"
    "github.com/mvillalba/caviar"
    "io/ioutil"
    "errors"
    "hash/crc32"
)

const MANIFEST_COMMENT =
`Generated by the Caviar resource packer for Go (http://github.com/mvillalba/caviar).
Copyright © 2014 Martín Raúl Villalba (http://www.martinvillalba.com/).`

type Args struct {
    cherrypick  bool
    detached    bool
    debug       bool
    executable  string
    prefix      string
    paths       []string
}

func parseArgs() (a Args) {
    cphelp := "add asset paths as sub-directories (rather than merge all contained files and directories across asset paths under one directory)."
    dthelp := "produce detached asset container."
    dbhelp := "enable Caviar's debug mode."
    pfhelp := "custom path prefix for asset root."
    flag.BoolVar(&a.cherrypick, "cherrypick", false, cphelp)
    flag.BoolVar(&a.detached, "detached", false, dthelp)
    flag.BoolVar(&a.debug, "debug", false, dbhelp)
    flag.StringVar(&a.prefix, "prefix", "", pfhelp)
    // TODO: extraction mode
    flag.Parse()

    if len(flag.Args()) < 2 {
        fmt.Println("Cavundle is part of the Caviar resource packer for Go (http://github.com/mvillalba/caviar).")
        fmt.Println("Copyright © 2014 Martín Raúl Villalba <martin@martinvillalba.com>")
        fmt.Println("")
        fmt.Println("Usage: %s [OPTIONS] EXECUTABLE ASSET-PATH-1[...ASSET-PATH-N]")
        flag.PrintDefaults()
        os.Exit(1)
    }

    a.executable = flag.Args()[0]
    for _, path := range flag.Args()[1:] {
        path, err := filepath.Abs(path)
        if err != nil { log.Fatal(err) }
        a.paths = append(a.paths, path)
    }

    return a
}


func processDirectory(obj *caviar.Object, dir string, buf *bytes.Buffer) error {
    dirlist, err := ioutil.ReadDir(dir)
    if err != nil { return err }
    for _, entry := range dirlist {
        entrypath := path.Join(dir, entry.Name())

        nobj := new(caviar.Object)
        nobj.Name = entry.Name()
        nobj.ModeBits = entry.Mode()
        nobj.ModTime = entry.ModTime().Unix()

        if entry.IsDir() {
            nobj.Size = 0
            nobj.Offset = 0
            nobj.Checksum = 0

            err := processDirectory(nobj, entrypath, buf)
            if err != nil { return err }
        } else {
            if entry.Size() == 0 {
                nobj.Size = 0
                nobj.Offset = 0
                nobj.Checksum = 0
            } else {
                nobj.Size = entry.Size()
                nobj.Offset = int64(buf.Len())

                payload, err := ioutil.ReadFile(entrypath)
                if err != nil { return err }

                buf.Write(payload)
                h := crc32.NewIEEE()
                h.Write(payload)
                nobj.Checksum = h.Sum32()
            }
        }

        obj.Objects = append(obj.Objects, *nobj)
    }

    return nil
}

func processAssets(args Args) (*caviar.Manifest, []byte, error) {
    // Init
    buf := new(bytes.Buffer)
    manifest := new(caviar.Manifest)
    manifest.Magic = caviar.MANIFEST_MAGIC
    manifest.Comment = MANIFEST_COMMENT
    manifest.ObjectRoot.Name = caviar.OBJECTROOT_MAGIC
    manifest.ObjectRoot.ModeBits = os.ModeDir | 0755;
    manifest.Options.Debug = args.debug
    manifest.Options.CustomPrefix = args.prefix
    manifest.Options.ExtractionMode = caviar.EXTRACT_MEMORY

    // Process each asset path individually
    for _, assetpath := range args.paths {
        if args.cherrypick { assetpath = filepath.Dir(assetpath) }
        err := processDirectory(&manifest.ObjectRoot, assetpath, buf)
        if err != nil { return nil, nil, err }
    }

    return manifest, buf.Bytes(), nil
}

func main() {
    args := parseArgs()

    // Container
    buf := new(bytes.Buffer)
    zw := zip.NewWriter(buf)

    // Pack assets
    manifest, assets, err := processAssets(args)
    if err != nil { log.Fatal(err) }

    f, _ := zw.Create("Manifest.gob")
    enc := gob.NewEncoder(f)
    err = enc.Encode(*manifest)
    if err != nil { log.Fatal(err) }

    f, _ = zw.Create("Assets.bin")
    _, err = f.Write(assets)
    if err != nil { log.Fatal(err) }

    // Clean up
    err = zw.Close()
    if err != nil {
        log.Fatal(err)
    }

    // Dump buffer
    fpath, err := filepath.Abs(args.executable)
    if err != nil { log.Fatal(err) }

    var fp *os.File
    if args.detached {
        fpath = caviar.DetachedName(fpath)
        fp, err = os.OpenFile(fpath, os.O_WRONLY | os.O_CREATE | os.O_TRUNC, 0664)
    } else {
        fp, err = os.OpenFile(fpath, os.O_WRONLY | os.O_APPEND, 0664)
    }
    if err != nil { log.Fatal(err) }

    buf.WriteTo(fp)

    fp.Sync()
    fp.Close()

    // Re-align container
    if args.detached { return }

    errprefix := "Zip align error: "
    cmd := exec.Command("zip", "-A", fpath)
    err = cmd.Start()
    if err != nil { log.Fatal(errors.New(errprefix + err.Error())) }
    err = cmd.Wait()
    if err != nil { log.Fatal(errors.New(errprefix + err.Error())) }
}
